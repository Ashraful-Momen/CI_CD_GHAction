Perfect! Letâ€™s make a **full end-to-end diagram and explanation** of your **Laravel CD workflow with Docker Swarm**, including exactly what happens **after you push code**. Iâ€™ll break it **step by step** with Docker updates and rolling deployment.

---

# **ðŸ”¥ Full CD Flow: Git Push â†’ Docker Swarm Update**

---

## **Step 0: You Push Code to GitHub**

```
Local PC
   â””â”€ git push origin main
```

**What you push:**

* Laravel project code (`app/`, `routes/`, `resources/`, etc.)
* `Dockerfile` (build image)
* `docker-compose.yml` (Swarm stack config)
* `.github/workflows/cd.yml` (workflow for deployment)

**What you do NOT push:**

* `.env`
* `vendor/` (optional, can be built on server)

---

## **Step 1: GitHub Actions Runner Triggers**

```
GitHub
   â””â”€ Actions runner (ubuntu-latest)
```

* Triggered because `on: push to main` in `.github/workflows/cd.yml`
* Steps run **one by one** on GitHub runner

---

## **Step 2: Checkout Code on Runner**

```
Runner
   â””â”€ git checkout main
```

* Gets latest Laravel project + Docker files
* Ready for deployment

---

## **Step 3: Setup SSH to VM**

```
Runner
   â””â”€ Setup SSH keys
       â”œâ”€ mkdir ~/.ssh
       â”œâ”€ write private key from GitHub secrets
       â”œâ”€ chmod 600 key
       â””â”€ ssh-keyscan VM_IP â†’ known_hosts
```

* Ensures **passwordless login** to VM
* Runner now can SSH into production VM securely

---

## **Step 4: SSH into VM and Pull Code**

```
Runner â”€sshâ†’ VM
   â””â”€ cd /var/www/lindos
       â””â”€ git pull origin main
```

* Server fetches latest Laravel + Docker files
* Old files replaced/updated automatically
* Laravel code is now **up-to-date**

---

## **Step 5: Deploy Docker Stack**

```
VM
   â””â”€ docker stack deploy -c docker-compose.yml lindos
```

**What happens here (rolling update):**

1. Swarm checks **current running containers** (replicas: 3)
2. Builds/uses `lindos_app:latest` Docker image (if local or pulled from registry)
3. Swarm **updates containers one by one** (`parallelism: 1`)
4. **Delay 10s between updates** to ensure healthy boot
5. Old containers replaced gradually â†’ **zero downtime**

```
Old Containers: [app1, app2, app3]
Update process:
  - Stop app1 â†’ start new app1 (wait 10s)
  - Stop app2 â†’ start new app2 (wait 10s)
  - Stop app3 â†’ start new app3 (wait 10s)
```

* All users continue accessing the app via remaining containers
* New code is now live

---

## **Step 6: Swarm Update Complete**

```
VM
   â””â”€ 3 running containers (updated)
   â””â”€ Service: lindos_app
```

* Swarm ensures **replicas = 3**
* Rolling update ensures **zero downtime**
* Ready for next Git push

---

## **Step 7: Optional Rollback**

If something goes wrong:

```bash
docker service update --rollback lindos_app
```

* Swarm **automatically restores previous container version**
* No downtime

---

# **ðŸ“Š Visual Diagram of the Flow**

```
[Local PC]
   â”‚
   â”‚ git push main
   â–¼
[GitHub Repo]
   â”‚
   â”‚ triggers
   â–¼
[GitHub Actions Runner]
   â”‚â”€ checkout code
   â”‚â”€ setup SSH
   â”‚â”€ ssh into VM
   â–¼
[VM / Production Server]
   â”‚â”€ cd /var/www/lindos
   â”‚â”€ git pull origin main
   â”‚â”€ docker stack deploy -c docker-compose.yml lindos
   â–¼
[Docker Swarm]
   â”‚â”€ Rolling update (parallelism: 1, delay: 10s)
   â”‚â”€ 3 updated replicas of Laravel app
   â–¼
[Users]
   â”‚â”€ Access live Laravel app
```

---

## âœ… **Key Notes**

1. You **push code to GitHub** â†’ CD workflow triggers automatically
2. Workflow **SSH into VM** â†’ pulls latest code â†’ deploys via Docker stack
3. **Docker Swarm rolling update** ensures zero downtime
4. Next push to main branch repeats the process
5. Rollback available if something goes wrong

---

I can also make a **diagram including Docker image build inside GitHub Actions** so **every push builds a fresh image and deploys automatically**, fully automated â€” this is the **best production setup**.

Do you want me to do that?
